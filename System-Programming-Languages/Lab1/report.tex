\documentclass[12pt,a4paper]{report}
\usepackage[a4paper, mag=1000, left=2.5cm, right=1cm, top=2cm, bottom=2cm, headsep=0.7cm, footskip=1cm]{geometry}
% Fonts
\usepackage{fontspec, unicode-math}
\setmainfont[Ligatures=TeX]{CMU Serif}
\setmonofont{CMU Typewriter Text}
\usepackage[english, russian]{babel}
% Indent first paragraph
\usepackage{indentfirst}
\setlength{\parskip}{5pt}
% Code listings
\usepackage[dvipsnames]{xcolor}
\usepackage{listings}

\begin{document}

\begin{titlepage}
\begin{center}
\textsc{
  National Research University ITMO\\[4mm]
  Department of Computational Technologies
}
\vfill
\textbf{
  Lab Report \#1\\[2mm]
  System Programming Languages
  \\[20mm]
}
Timothy Labushev\\[2mm]
Group P3202
\vfill
Saint Petersburg\\[2mm]
2018
\end{center}
\end{titlepage}

\newpage
\section*{Assignment}

This report discusses the implementation of a set of basic I/O routines in x86-64 assembly, using the Linux system call ABI.

The following routines were implemented:

\begin{enumerate}
\setlength\itemsep{0.2em}
\item \textbf{string\_length}: accepts a pointer to a null-terminated string and returns its length
\item \textbf{print\_string}: accepts a pointer to a null-terminated string and prints it to stdout
\item \textbf{print\_char}: accepts a character code directly and prints it to stdout
\item \textbf{print\_newline}: prints a character with code 0xA to stdout
\item \textbf{print\_uint}: outputs an unsigned 64-bit integer in decimal format
\item \textbf{print\_int}: outputs a signed 64-bit integer in decimal format
\item \textbf{read\_char}: reads one character from stdin and returns it; returns 0 if the end of input stream occurs
\item \textbf{read\_word}: accepts a buffer address and size as arguments. Reads next word from stdin (skipping leading whitespace). Stops and returns 0 if the word exceeds the buffer size, otherwise returns a buffer address
\item \textbf{parse\_uint}: accepts a null-terminated string and tries to parse an unsigned number from its start
\item \textbf{parse\_int}: accepts a null-terminated string and tries to parse a signed number from its start
\item \textbf{string\_equals}: accepts two pointers to strings and compares them, returning 1 if they are equal, otherwise 0
\item \textbf{string\_copy}: accepts a pointer to a string, a pointer to a buffer, and bufferâ€™s length. Copies the source string to the destination buffer, returning the latter's address if the string fits within the buffer; otherwise 0
\end{enumerate}

A script for automated tests of correctness is provided, which the implementation is required to pass. One of the requirements is that functions preserve callee-saved registers; in addition to that, temporary buffers should be allocated on stack.

\section*{Code Listing}

\lstinputlisting[firstline=3, basicstyle=\scriptsize]{lib.inc}

\section*{Lessons Learned}

While completing the assignment, I have familiarized myself with the basic instructions of x86-64 ISA and become more confident writing simple assembly routines. The control flow in particular required getting used to due to the absence of higher-level concepts such as conditional (\texttt{if-else}) and looping (\texttt{for}, \texttt{while}) constructs.

\end{document}
